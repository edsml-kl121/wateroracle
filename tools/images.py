import json
from pprint import pprint
import numpy as np
import tqdm.notebook as tq
import tensorflow as tf
import ee
import subprocess
import ast


__all__ = ["doExport", "predictionSingleinput", "predictionMultipleinput", "predictionMultipleinput_3", \
           "uploadToGEEAsset", "LoadImage", "doPrediction_featurestack", \
            "doPrediction_multiview_2", "doPrediction_multiview_3"]


def doExport(out_image_base, kernel_buffer, region, setting, extra_folder= ""):
  """
  Export the image with features and area of interest
  to google cloud bucket. The function doesn't exit until
  the task is complete. The optional extra_folder arguement lets you put
  the exported tf.record.gz in a folder

  Parameters
  ----------
  out_image_base : string
  kernel_buffer : list
  region : ee.Geometry.BBox
  setting : dict
  extra_folder : string

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  if extra_folder == "":
    fileNamePrefix_ = setting.FOLDER + '/' + out_image_base
  else:
    fileNamePrefix_ = setting.FOLDER + '/' + extra_folder + '/' + out_image_base
  task = ee.batch.Export.image.toCloudStorage(
    image = setting.image.select(setting.BANDS),
    description = out_image_base,
    bucket = setting.BUCKET,
    fileNamePrefix = fileNamePrefix_,
    region = region.getInfo()['coordinates'],
    scale = 30,
    fileFormat = 'TFRecord',
    maxPixels = 1e10,
    formatOptions = {
      'patchDimensions': setting.KERNEL_SHAPE,
      'kernelSize': kernel_buffer,
      'compressed': True,
      'maxFileSize': 104857600
    }
  )
  task.start()

  # Block until the task completes.
  print('Running image export to Cloud Storage...')
  import time
  while task.active():
    time.sleep(30)

  # Error condition
  if task.status()['state'] != 'COMPLETED':
    print('Error with image export.')
  else:
    print('Image export completed.')


def LoadImage(out_image_base, user_folder, kernel_buffer, setting, extra_folder = ""):
  """
  Load the image from the google cloud bucket and preprocess the image for prediction
  and provide crutial information for exporting to GEE asset

  Parameters
  ----------
  out_image_base : string
  user_folder : string
  kernel_buffer : list
  setting : dict
  extra_folder : string

  Notes
  -----
  The code is obtained/modified from:

  Returns
  ----------
  imageDataset as tensor data for prediction, patches as int, x_buffer as int, y_buffer as int, jsonFile as string

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  print('Looking for TFRecord files...')

  # Get a list of all the files in the output bucket.
  if extra_folder == "":
    process = subprocess.run(["gsutil", "ls", f'gs://{setting.BUCKET}/{setting.FOLDER}'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    filesList = process.stdout.split('\n')
  else:
    process = subprocess.run(["gsutil", "ls", f'gs://{setting.BUCKET}/{setting.FOLDER}/{extra_folder}'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    filesList = process.stdout.split('\n')

  print(filesList)
  # Get only the files generated by the image export.
  exportFilesList = [s for s in filesList if out_image_base in s]
  print(exportFilesList)
  # Get the list of image files and the JSON mixer file.
  imageFilesList = []
  jsonFile = None
  for f in exportFilesList:
    if f.endswith('.tfrecord.gz'):
      imageFilesList.append(f)
    elif f.endswith('.json'):
      jsonFile = f

  # Make sure the files are in the right order.
  imageFilesList.sort()

  pprint(imageFilesList)
  print(jsonFile)
  if jsonFile == None:
    return "image path doesn't exist"

  # Load the contents of the mixer file to a JSON object.
  process = subprocess.run(["gsutil", "cat", f'{jsonFile}'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
  jsonText = process.stdout
  # Get a single string w/ newlines from the IPython.utils.text.SList
  # mixer = json.loads(jsonText.nlstr)
  mixer = ast.literal_eval(jsonText)
  pprint(mixer)
  patches = mixer['totalPatches']

  # Get set up for prediction.
  x_buffer = int(kernel_buffer[0] / 2)
  y_buffer = int(kernel_buffer[1] / 2)

  buffered_shape = [
      setting.KERNEL_SHAPE[0] + kernel_buffer[0],
      setting.KERNEL_SHAPE[1] + kernel_buffer[1]]

  imageColumns = [
    tf.io.FixedLenFeature(shape=buffered_shape, dtype=tf.float32) 
      for k in setting.BANDS
  ]

  def parse_image(example_proto):
    """
    The parsing function Read a serialized example into the structure defined by FEATURES_DICT.

    Parameters
    ----------
    example_proto: a serialized Example

    Returns
    ----------
    A dictionary of tensors, keyed by feature name.

    Notes
    -----
    The code is obtained/modified from:

    https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
    """
    return tf.io.parse_single_example(example_proto, imageFeaturesDict)

  def toTupleImage(inputs):
    """
    Function to convert a dictionary of tensors to a tuple of (inputs, outputs).
    Turn the tensors returned by parse_tfrecord into a stack in HWC shape.
    Parameters
    ----------
    inputs: A dictionary of tensors, keyed by feature name.

    Returns
    ----------
    A tuple of (inputs, outputs).

    Notes
    -----
    The code is obtained/modified from:

    https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
    """
    inputsList = [inputs.get(key) for key in setting.BANDS]
    stacked = tf.stack(inputsList, axis=0)
    stacked = tf.transpose(stacked, [1, 2, 0])
    return stacked

  imageFeaturesDict = dict(zip(setting.BANDS, imageColumns))
  imageDataset = tf.data.TFRecordDataset(imageFilesList, compression_type='GZIP')
  imageDataset = imageDataset.map(parse_image, num_parallel_calls=5)
  imageDataset = imageDataset.map(toTupleImage).batch(1)
  return imageDataset, patches, x_buffer, y_buffer, jsonFile

def predictionSingleinput(model, imageDataset, patches):
  """
  Given the model, and image for prediction, predict the image
  with feature stack U-Net

  Parameters
  ----------
  model : model : keras.engine.functional.Functional
  imageDataset : tf.data.Dataset of training data (BatchDataset)
  patches : int

  Returns
  ----------
  A tf.float32 with same dimension as imageDataset

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  print('Running predictions...')
  predictions = model.predict(imageDataset, steps=patches, verbose=1)
  return predictions

def predictionMultipleinput(model, imageDataset, patches, setting):
  """
  Given the model, and image for prediction, predict the image
  with Multi-view learning U-Net

  Parameters
  ----------
  model : model : keras.engine.functional.Functional
  imageDataset : tf.data.Dataset of training data (BatchDataset)
  patches : int
  setting : dict

  Returns
  ----------
  A tf.float32 with same dimension as imageDataset

  Notes
  -----
  The code is modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  print('Running predictions...')
  predictions = []
  pbar = tq.tqdm(total=patches)
  for data in imageDataset:
    pbar.update(1)
    x1, x2 = tf.split(data, [len(setting.BANDS1), len(setting.BANDS2)], 3)
    predictions.append(model.predict([x1, x2], verbose=0))
  return predictions

def predictionMultipleinput_3(model, imageDataset, patches, setting):
  """
  Given the model, and image for prediction, predict the image
  with Multi-view learning U-Net with 3 inputs

  Parameters
  ----------
  model : model : keras.engine.functional.Functional
  imageDataset : tf.data.Dataset of training data (BatchDataset)
  patches : int
  setting : dict

  Returns
  ----------
  A tf.float32 with same dimension as imageDataset

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  print('Running predictions...')
  predictions = []
  pbar = tq.tqdm(total=patches)
  for data in imageDataset:
    pbar.update(1)
    x1, x2, x3 = tf.split(data, [len(setting.BANDS1), len(setting.BANDS2), len(setting.BANDS3)], 3)
    predictions.append(model.predict([x1, x2, x3], verbose=0))
  return predictions

def uploadToGEEAsset(x_buffer, y_buffer, predictions, out_image_base, jsonFile, suffix, setting, multiview=False, user_folder='users/mewchayutaphong'):
  """
  Given the predictions, exported file location other information
  on the image to be exported, return the required information
  in order to export the predicted image to the GEE asset

  Parameters
  ----------
  x_buffer : int
  y_buffer : int
  predictions : tf.data.Dataset of training data (BatchDataset)
  out_image_base : string
  jsonFile : string
  suffix : string
  setting : dict
  user_folder : string

  Returns
  ----------
  A out_image_asset a location to the output GEE asset folder
  as a string, out_image_file of the prediction as TFRecord and the
  corresponding json file.

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  print('Writing predictions...')
  out_image_file = 'gs://' + setting.BUCKET + '/' + setting.FOLDER + '/' + out_image_base + '.TFRecord'
  writer = tf.io.TFRecordWriter(out_image_file)
  patches = 0
  for predictionPatch in predictions:
    if multiview == True:
      predictionPatch = predictionPatch[0]
    print('Writing patch ' + str(patches) + '...')
    predictionPatch = predictionPatch[
        x_buffer:x_buffer+setting.KERNEL_SIZE, y_buffer:y_buffer+setting.KERNEL_SIZE]
    predictionPatch = np.argmax(predictionPatch, -1)
    example = tf.train.Example(
      features=tf.train.Features(
        feature={
          'prediction': tf.train.Feature(
              float_list=tf.train.FloatList(
                  value=predictionPatch.flatten()))
        }
      )
    )
    # Write the example.
    writer.write(example.SerializeToString())
    patches += 1

  writer.close()
 
  # Start the upload.
  out_image_asset = user_folder + '/' + out_image_base + suffix
  # !earthengine upload image --asset_id={out_image_asset} {out_image_file} {jsonFile}
  return out_image_asset, out_image_file, jsonFile


def doPrediction_featurestack(out_image_base, user_folder, kernel_buffer, model, suffix, setting, extra_folder=""):
  """
  Putting all the image functions together. Load the Image, predict the output with featurestack U-Net, return information
  ready to be exported to GEE asset
  ----------
  pattern: A file pattern to match in a Cloud Storage bucket.

  Returns
  ----------
  A out_image_asset a location to the output GEE asset folder
  as a string, out_image_file of the prediction as TFRecord and the
  corresponding json file.

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  output_load_image = LoadImage(out_image_base, user_folder, kernel_buffer, setting, extra_folder)
  if type(output_load_image) == str:
    return "wrong file location"
  imageDataset, patches, x_buffer, y_buffer, jsonFile = output_load_image
  predictions = predictionSingleinput(model, imageDataset, patches)
  out_image_asset, out_image_file, jsonFile = uploadToGEEAsset(x_buffer, y_buffer, predictions, out_image_base, jsonFile, suffix, setting, False)
  return out_image_asset, out_image_file, jsonFile

def doPrediction_multiview_2(out_image_base, user_folder, kernel_buffer, model, suffix, setting, extra_folder=""):
  """
  Putting all the image functions together. Load the Image, predict the output with 
  Multi-view U-Net (2 inputs), return information ready to be exported to GEE asset
  ----------
  pattern: A file pattern to match in a Cloud Storage bucket.

  Returns
  ----------
  A out_image_asset a location to the output GEE asset folder
  as a string, out_image_file of the prediction as TFRecord and the
  corresponding json file.

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  output_load_image = LoadImage(out_image_base, user_folder, kernel_buffer, setting, extra_folder)
  if type(output_load_image) == str:
    return "wrong file location"
  imageDataset, patches, x_buffer, y_buffer, jsonFile = output_load_image
  predictions = predictionMultipleinput(model, imageDataset, patches, setting)
  out_image_asset, out_image_file, jsonFile = uploadToGEEAsset(x_buffer, y_buffer, predictions, out_image_base, jsonFile, suffix, setting, True)
  return out_image_asset, out_image_file, jsonFile

def doPrediction_multiview_3(out_image_base, user_folder, kernel_buffer, model, suffix, setting, extra_folder=""):
  """
  Putting all the image functions together. Load the Image, predict the output with 
  Multi-view U-Net (3 inputs), return information ready to be exported to GEE asset
  ----------
  pattern: A file pattern to match in a Cloud Storage bucket.

  Returns
  ----------
  A out_image_asset a location to the output GEE asset folder
  as a string, out_image_file of the prediction as TFRecord and the
  corresponding json file.

  Notes
  -----
  The code is obtained/modified from:

  https://github.com/google/earthengine-api/blob/master/python/examples/ipynb/UNET_regression_demo.ipynb
  """
  output_load_image = LoadImage(out_image_base, user_folder, kernel_buffer, setting, extra_folder)
  if type(output_load_image) == str:
    return "wrong file location"
  imageDataset, patches, x_buffer, y_buffer, jsonFile = output_load_image
  predictions = predictionMultipleinput_3(model, imageDataset, patches, setting)
  out_image_asset, out_image_file, jsonFile = uploadToGEEAsset(x_buffer, y_buffer, predictions, out_image_base, jsonFile, suffix, setting, True)
  return out_image_asset, out_image_file, jsonFile